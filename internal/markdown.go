package internal

import (
	"fmt"
	"io"
	"slices"
	"strings"
)

// icon is a collection of emoji icons used in the markdown report.
var icon = struct {
	redBook    string
	orangeBook string
	yellowBook string
	greenBook  string
	redDot     string
	greenTick  string
	mutedBell  string
}{
	redBook:    "ðŸ“•", // :closed_book:
	orangeBook: "ðŸ“™", // :orange_book:
	yellowBook: "ðŸ“’", // :ledger:
	greenBook:  "ðŸ“—", // :green_book:
	redDot:     "ðŸ”´", // :red_circle:
	greenTick:  "âœ…", // :white_check_mark:
	mutedBell:  "ðŸ”•", // :no_bell:
}

// markdown is a markdown report writer.
type markdown struct {
	title string
	mode  reportMode
	*IndentWriter
	*testrun
}

// getReportIcon returns the icon to use for the report based on the
// testrun pass rate %age and number of failed and skipped tests.
func (m markdown) getReportIcon() string {
	if m.numFailed == 0 && m.numSkipped > 0 {
		return icon.yellowBook
	}

	switch {
	case m.percentPassed == 100:
		return icon.greenBook
	case m.percentPassed > 94:
		return icon.yellowBook
	case m.percentPassed > 84:
		return icon.orangeBook
	default:
		return icon.redBook
	}
}

// export produces a markdown report to the specified writer.
func (m *markdown) export(w io.Writer) error {
	m.IndentWriter = &IndentWriter{output: w}

	icon := m.getReportIcon()
	m.WriteLn("## %s&nbsp;&nbsp;%s", icon, m.title)
	m.WriteLn()

	m.writeSummary()
	if m.numFailed > 0 && (m.mode != rmSummaryOnly) {
		m.writeDetail()
	}

	m.WriteLn()
	m.WriteLn("<hr>")
	m.WriteLn()
	m.WriteLn("_markdown test report generated by https://github.com/blugnu/test-report_")

	return m.error
}

// writeSummary writes the summary section of the markdown report.
func (m markdown) writeSummary() {
	writeRow := func(i string, h string, v string) {
		m.WriteXMLElement(func() {
			m.WriteLn("<td colspan=3 align='right'>%s</td>", i)
			m.WriteLn("<td>%s</td>", h)               //NOSONAR
			m.WriteLn("<td align='right'>%s</td>", v) //NOSONAR
		}, "tr")
	}

	m.WriteXMLElement(func() {
		m.WriteXMLElement(func() {
			m.WriteLn("<td><b>packages</b></td>")
			m.WriteLn("<td>%d</td>", len(m.packages)) //NOSONAR
			m.WriteLn("<td>%s</td>", m.elapsed)       //NOSONAR
			m.WriteLn("<td><b>tests</b></td>")
			m.WriteLn("<td align='right'>%d</td>", m.numTests) //NOSONAR
		}, "tr")
		if m.numFailed > 0 {
			writeRow(icon.redDot, "failed", fmt.Sprintf("%d", m.numFailed))
		}
		if m.numSkipped > 0 {
			writeRow(icon.mutedBell, "skipped", fmt.Sprintf("%d", m.numSkipped))
		}
		writeRow(m.getReportIcon(), "passed", fmt.Sprintf("%d%%", m.percentPassed))
	}, "table")
}

// writeDetail writes the detailed test results for the markdown report.
func (m markdown) writeDetail() {
	writeRow := func(icon string, n int, s1 string, sN string) {
		if n == 0 {
			return
		}

		s := map[bool]string{
			true:  s1,
			false: sN,
		}[n == 1]

		m.WriteXMLElement(func() {
			m.WriteLn("<td>%s</td>", icon) //NOSONAR
			m.WriteLn("<td colspan=3><b>%d %s</b></td>", n, s)
		}, "tr")
	}

	m.WriteXMLElement(func() {
		for _, p := range m.packages {
			m.writePackage(p)
		}

		if m.mode == rmFailedTests {
			writeRow(icon.mutedBell, m.numSkipped, "test was skipped", "tests were skipped")
			writeRow(icon.greenTick, m.numPassed, "test passed", "tests passed")
		}
	}, "table")
}

// writePackage writes the test results for a package.  If the mode
// is rmAllTests, then all tests are written (including passed and
// skipped tests).  Otherwise, only failed tests are written.
func (m markdown) writePackage(p *packageinfo) {
	if (m.mode == rmAllTests) || !p.passed {
		icon := map[bool]string{
			true:  icon.greenTick,
			false: icon.redDot,
		}

		m.WriteXMLElement(func() {
			m.WriteLn("<td>%s</td>", icon[p.passed]) //NOSONAR
			m.WriteLn("<td colspan='2'><b>%s</b></td>", p.name)
			m.WriteLn("<td align='right'>%s</td>", p.elapsed)
		}, "tr")
		m.writeTests(p)
	}
}

// writeTests writes the test results for a package.  If the mode
// is rmAllTests, then all tests are written (including passed and
// skipped tests).  Otherwise, only failed tests are written.
func (m markdown) writeTests(p *packageinfo) {
	icon := map[testResult]string{
		trPassed:  icon.greenTick,
		trFailed:  icon.redDot,
		trSkipped: icon.mutedBell,
	}
	for _, t := range p.tests {
		if t.result == trFailed || (m.mode == rmAllTests) {
			m.WriteXMLElement(func() {
				m.WriteLn("<td></td>")
				m.WriteLn("<td>%s</td>", icon[t.result]) //NOSONAR
				m.WriteXMLElement(func() {
					m.WriteLn("<b>%s</b>", t.path)
					m.writeOutput(t.output)
				}, "td")
				m.WriteLn("<td align='right'>%s</td>", t.elapsed)
			}, "tr", "valign='top'")
		}
	}
}

// writeOutput writes the output of a test.  Each source in the
// output is written with the source reference on a new line,
// followed by the output associated with that source:
//
// # Examples
//
//	// (1 line of output):
//	<div><i>source_test.go:1</i></div>
//	<pre>output line 1</pre>
//
//	// (2 lines of output):
//	<div><i>source_test.go:2</i></div>
//	<pre>output line 1
//	output line 2</pre>
//
// NOTE: The rendered output has space characters replaced with
// "&nbsp;" to prevent the markdown renderer from wrapping lines
// of output.
func (m markdown) writeOutput(output map[string][]string) {
	keys := []string{}
	for k := range output {
		keys = append(keys, k)
	}
	slices.Sort(keys)

	for _, ref := range keys {
		log := output[ref]
		m.WriteLn("<div><i>%s</i></div>", ref)
		m.Write("<pre>%s", strings.Replace(log[0], " ", "&nbsp;", -1))
		m.WriteIndented(func() {
			for _, s := range log[1:] {
				m.Write("\n%s", strings.Replace(s, " ", "&nbsp;", -1))
			}
			m.WriteLn("</pre>")
		})
	}
}
